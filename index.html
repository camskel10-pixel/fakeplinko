<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Plinko — Offline (Side Selectors, 3D, Anti‑Stick, Flat Top)</title>
<style>
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0b1220;color:#e9eef9}
  /* Offline: system font stack only */
  body{font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale}

  /* Canvas fills view; board is laid out between side panels in JS */
  #stage{display:block;width:100%;height:100dvh;touch-action:manipulation;background:radial-gradient(1200px 800px at 50% 15%, rgba(130,170,255,.10), rgba(0,0,0,0))}

  /* —— Side Panels (selectors on the sides) —— */
  :root{
    --sideW: clamp(200px, 26vw, 300px);
    --cardTop:#233045; --cardBot:#1b273b; --edge:#2a3a54; --muted:#9fb3d8; --accent:#8cb6ff;
    --btnTop:#1f2d46; --btnBot:#11213a; --btnEdge:#3a5176; --greenTop:#2af07a; --greenBot:#17b856;
    --chipRed:#ef2b43; --chipOrange:#ff6b2e; --chipAmber:#ff9c2e; --chipYellow:#ffc43c; --chipPale:#ffd95a;
  }
  .side{position:fixed;top:0;bottom:0;width:var(--sideW);padding:12px;display:flex;flex-direction:column;gap:12px;z-index:3}
  #left{left:0;background:linear-gradient(180deg,#1f2b43,#182439);border-right:1px solid var(--edge);box-shadow:8px 0 24px rgba(0,0,0,.35)}
  #right{right:0;background:linear-gradient(180deg,#1c263c,#152136);border-left:1px solid var(--edge);box-shadow:-8px 0 24px rgba(0,0,0,.35)}
  .card{border:1px solid var(--edge);border-radius:14px;padding:10px;background:linear-gradient(180deg,var(--cardTop),var(--cardBot));box-shadow:inset 0 1px 0 rgba(255,255,255,.06), inset 0 -1px 0 rgba(0,0,0,.25)}
  .title{font-weight:800;letter-spacing:.2px;color:var(--muted);margin:2px 2px 8px}
  .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .seg{display:flex;border:1px solid var(--btnEdge);border-radius:12px;overflow:hidden}
  .seg>button{border:0;min-width:40px;height:36px;padding:0 12px;color:#e9eef9;background:linear-gradient(180deg,var(--btnTop),var(--btnBot));cursor:pointer}
  .seg>button.active{background:linear-gradient(180deg,#274165,#193052)}
  input[type=number], select{height:36px;padding:6px 10px;border-radius:10px;border:1px solid var(--btnEdge);background:linear-gradient(180deg,#13213a,#0f1a2f);color:#e9eef9;min-width:74px;font-weight:700}
  input[type=range]{flex:1}
  .btn{height:42px;border-radius:12px;border:1px solid rgba(0,0,0,.25);font-weight:900;letter-spacing:.2px;cursor:pointer}
  .btn.green{color:#062312;background:linear-gradient(180deg,var(--greenTop),var(--greenBot));box-shadow:0 10px 24px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.35)}
  .btn.dark{color:#e9eef9;background:linear-gradient(180deg,#192b48,#0f1a30);border-color:var(--btnEdge)}
  .stat{font-weight:800;letter-spacing:.2px;text-align:center}

  /* Mobile squeeze */
  @media (max-width: 860px){ :root{--sideW: 200px;} }
</style>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
</head>
<body>
  <!-- Left controls (selectors on the side) -->
  <aside id="left" class="side" aria-label="Controls">
    <div class="card">
      <div class="title">Mode</div>
      <div class="seg" role="tablist">
        <button id="manualBtn" class="active" role="tab" aria-selected="true">Manual</button>
        <button id="autoBtn" role="tab" aria-selected="false">Auto</button>
      </div>
    </div>
    <div class="card">
      <div class="title">Bet</div>
      <div class="row">
        <button id="betHalf" class="btn dark" style="height:36px">½</button>
        <input id="bet" type="number" min="0.1" step="0.1" value="1.0" inputmode="decimal"/>
        <button id="betDouble" class="btn dark" style="height:36px">2×</button>
      </div>
    </div>
    <div class="card">
      <div class="title">Risk</div>
      <select id="risk">
        <option value="low">Low</option>
        <option value="medium" selected>Medium</option>
        <option value="high">High</option>
      </select>
    </div>
    <div class="card">
      <div class="title">Rows <span id="rowsLabel" style="float:right;color:#cfe0ff"></span></div>
      <div class="row"><input id="rows" type="range" min="8" max="16" value="12"/></div>
    </div>
    <button id="dropBtn" class="btn green">Drop Ball</button>
  </aside>

  <!-- Right info (stats) -->
  <aside id="right" class="side" aria-label="Stats">
    <div class="card stat">Balance<br><span id="balance" style="font-size:20px">$1000.00</span></div>
    <div class="card stat">Streak<br><span id="streak" style="font-size:20px">x1</span></div>
  </aside>

  <canvas id="stage" aria-label="Plinko board (tap near the top to drop)"></canvas>

<script>
(function(){
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const L = document.getElementById('left');
  const R = document.getElementById('right');

  // UI refs
  const manualBtn = document.getElementById('manualBtn');
  const autoBtn   = document.getElementById('autoBtn');
  const betEl     = document.getElementById('bet');
  const betHalf   = document.getElementById('betHalf');
  const betDouble = document.getElementById('betDouble');
  const riskEl    = document.getElementById('risk');
  const rowsEl    = document.getElementById('rows');
  const rowsLabel = document.getElementById('rowsLabel');
  const dropBtn   = document.getElementById('dropBtn');
  const balanceEl = document.getElementById('balance');
  const streakEl  = document.getElementById('streak');

  // DPR and size
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  let W=0, H=0; const TAU = Math.PI*2;

  // Geometry & physics
  const TOP_START_COUNT = 3; // flat top: first row has 3 pegs
  let rows = parseInt(rowsEl.value,10);
  let pegs=[], slots=[], balls=[];
  let leftPad=0, rightPad=0; // space for sidebars
  let topOffset = 68; // px
  let pegSpacingX=30, pegSpacingY=34, pegRadius=5;

  // Trapezoid frame points
  let topLeft={x:0,y:0}, topRight={x:0,y:0}, baseLeft={x:0,y:0}, baseRight={x:0,y:0};
  let nLeft={x:0,y:0}, nRight={x:0,y:0}; // inward normals for side walls

  // ===== Physics engine config =====
  const DEFAULT_PHYSICS = {
    gravity: 1,
    pegBounce: 0.9,
    ballMass: 1,
    airDrag: 0.01,
    mode: 'normal'
  };
  let physicsConfig = { ...DEFAULT_PHYSICS };

  async function loadPhysicsConfig(){
    try{
      const res = await fetch('/api/physics-config');
      if(res.ok){ const data = await res.json(); physicsConfig = { ...physicsConfig, ...data }; return; }
    }catch(e){}
    if(window.PHYSICS_CONFIG){ physicsConfig = { ...physicsConfig, ...window.PHYSICS_CONFIG }; }
  }

  const engine = Matter.Engine.create();
  const world = engine.world;
  world.gravity.y = physicsConfig.gravity;
  engine.world.broadphase = new Matter.Grid();
  const SPAWN_HEIGHT = 60;

  // Mode tweaks
  function applyMode(){
    if(physicsConfig.mode === 'low-gravity') world.gravity.y = physicsConfig.gravity * 0.5;
    if(physicsConfig.mode === 'high-bounce') defaultRestitution = physicsConfig.pegBounce * 1.3;
  }
  let defaultRestitution = physicsConfig.pegBounce;

  // State
  let auto=false, lastDrop=0, dropInterval=240;
  let balance=1000, streak=1;

  // RNG
  let seed = Date.now()>>>0;
  if(window.PLINKO_SEED !== undefined) seed = window.PLINKO_SEED>>>0;
  let rng = mulberry32(seed);

  // ===== Size & layout =====
  function size(){
    const cssW = window.innerWidth; const cssH = window.innerHeight;
    canvas.style.width = cssW+'px'; canvas.style.height = cssH+'px';
    canvas.width = Math.floor(cssW*DPR); canvas.height = Math.floor(cssH*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    W = cssW; H = cssH;
    leftPad  = Math.ceil(L.getBoundingClientRect().width) + 10;
    rightPad = Math.ceil(R.getBoundingClientRect().width) + 10;
    buildBoard();
  }
  addEventListener('resize', size);
  addEventListener('orientationchange', ()=> setTimeout(size, 80));

  // ===== Build board with flat top =====
  function inwardNormal(ax,ay,bx,by){ let nx=-(by-ay), ny=(bx-ax); const len=Math.hypot(nx,ny)||1; nx/=len; ny/=len; const cx=(ax+bx)/2, cy=(ay+by)/2; // aim normal roughly toward canvas center
    const toC = (W/2-cx)*nx + (H/2-cy)*ny; if(toC<0){ nx=-nx; ny=-ny; } return {x:nx,y:ny}; }

  function buildBoard(){
    rows = parseInt(rowsEl.value,10); rowsLabel.textContent = rows;
    pegs.length=0; slots.length=0;

    // Available width between sidebars
    const availW = Math.max(220, W - leftPad - rightPad);
    pegSpacingY = Math.min(44, Math.max(26, Math.floor((H-220)/rows)));
    pegSpacingX = Math.min(48, Math.max(24, Math.floor(availW/(TOP_START_COUNT + rows))));
    pegRadius   = Math.max(4, Math.min(6, Math.floor(Math.min(pegSpacingX,pegSpacingY)*0.22)));
    topOffset   = Math.max(58, Math.min(120, Math.floor(H*0.11)));

    // Row 0 has 3 pegs; last row has TOP_START_COUNT + rows - 1 pegs
    const firstCount = TOP_START_COUNT;
    const lastCount  = TOP_START_COUNT + rows - 1;
    const baseY = topOffset + (rows-1)*pegSpacingY + 36;

    // Top segment across first row, slightly wider than pegs
    const firstRowWidth = (firstCount-1)*pegSpacingX;
    const centerX = leftPad + availW/2;
    topLeft  = {x: centerX - firstRowWidth/2 - 12, y: topOffset};
    topRight = {x: centerX + firstRowWidth/2 + 12, y: topOffset};

    // Base corners under last row
    const lastRowWidth = (lastCount-1)*pegSpacingX;
    baseLeft  = {x: centerX - lastRowWidth/2 - 16, y: baseY};
    baseRight = {x: centerX + lastRowWidth/2 + 16, y: baseY};

    // Side wall normals
    nLeft  = inwardNormal(topLeft.x, topLeft.y, baseLeft.x, baseLeft.y);
    nRight = inwardNormal(topRight.x, topRight.y, baseRight.x, baseRight.y);

    // Build pegs (3,4,5,...)
    for(let r=0;r<rows;r++){
      const count = firstCount + r; const y = topOffset + r*pegSpacingY;
      const rowWidth=(count-1)*pegSpacingX; const startX=centerX - rowWidth/2;
      for(let c=0;c<count;c++) pegs.push({x:startX + c*pegSpacingX, y, r:pegRadius});
    }

    // Slots align to last row spacing
    const nSlots=lastCount+1; const slotW=pegSpacingX; const startX = centerX - (nSlots-1)*slotW/2;
    for(let i=0;i<nSlots;i++) slots.push({x:startX + i*slotW, y: baseY, w: slotW, mult:1});
    // build Matter.js bodies
    pegBodies.forEach(b=>Matter.World.remove(world,b)); pegBodies.length=0;
    wallBodies.forEach(b=>Matter.World.remove(world,b)); wallBodies.length=0;
    for(const p of pegs){ const body=Matter.Bodies.circle(p.x,p.y,p.r,{isStatic:true,restitution:defaultRestitution,label:'peg'}); pegBodies.push(body); }
    const thickness=20;
    const leftWall = Matter.Bodies.rectangle((topLeft.x+baseLeft.x)/2,(topLeft.y+baseLeft.y)/2,thickness,Math.hypot(baseLeft.x-topLeft.x,baseLeft.y-topLeft.y),{isStatic:true,angle:Math.atan2(baseLeft.y-topLeft.y,baseLeft.x-topLeft.x),restitution:defaultRestitution,label:'wall'});
    const rightWall = Matter.Bodies.rectangle((topRight.x+baseRight.x)/2,(topRight.y+baseRight.y)/2,thickness,Math.hypot(baseRight.x-topRight.x,baseRight.y-topRight.y),{isStatic:true,angle:Math.atan2(baseRight.y-topRight.y,baseRight.x-topRight.x),restitution:defaultRestitution,label:'wall'});
    const floor = Matter.Bodies.rectangle((baseLeft.x+baseRight.x)/2,baseLeft.y+thickness/2,baseRight.x-baseLeft.x,thickness,{isStatic:true,restitution:defaultRestitution,label:'floor'});
    wallBodies.push(leftWall,rightWall,floor);
    Matter.World.add(world,[...pegBodies,...wallBodies]);
    updateMultipliers();
  }

  // ===== Multipliers sized to slots =====
  const factCache={}; function fact(n){ if(factCache[n]) return factCache[n]; let r=1; for(let i=2;i<=n;i++) r*=i; return factCache[n]=r; }
  const comb=(n,k)=> fact(n)/(fact(k)*fact(n-k));
  function binom(n,k,p){ return comb(n,k)*Math.pow(p,k)*Math.pow(1-p,n-k); }
  function buildMultipliers(effectiveRows, risk){
    // effectiveRows equals lastCount for slot count - 1
    const nSlots=effectiveRows+1; const nRows=effectiveRows; const probs=[]; for(let k=0;k<nSlots;k++) probs.push(binom(nRows,k,0.5));
    let edgeBoost, centerPenalty; if(risk==='high'){edgeBoost=4.2;centerPenalty=0.52;} else if(risk==='low'){edgeBoost=2.1;centerPenalty=0.86;} else {edgeBoost=3.0;centerPenalty=0.70;}
    const mid=(nSlots-1)/2, raw=[]; for(let k=0;k<nSlots;k++){ const d=Math.abs(k-mid)/mid; const shape=1+d*(edgeBoost-1); const centerAdj=1-(1-centerPenalty)*(1-d); raw.push(shape*centerAdj); }
    const rtp=0.98; let expected=0; for(let i=0;i<nSlots;i++) expected += probs[i]*raw[i]; const scale=rtp/expected;
    return raw.map(v=>{ const m=Math.max(0.1, Math.round(v*scale*100)/100); if(m>=10) return Math.round(m); if(m>=5) return Math.round(m*2)/2; return Math.round(m*10)/10; });
  }
  function updateMultipliers(){
    // effective rows equals lastCount (top row count 3 then growing)
    const effectiveRows = TOP_START_COUNT + rows - 1;
    const arr=buildMultipliers(effectiveRows, riskEl.value);
    for (let i=0;i<slots.length;i++) slots[i].mult=arr[i]||arr[arr.length-1];
  }

  // ===== Physics with Matter.js =====
  const pegBodies=[];
  const wallBodies=[];

  class Ball{
    constructor(x,y){
      const r=Math.max(4,pegRadius); this.r=r;
      this.body = Matter.Bodies.circle(x,y,r,{restitution:defaultRestitution, friction:0, frictionAir:physicsConfig.airDrag, mass:physicsConfig.ballMass, label:'ball'});
      Matter.World.add(world,this.body); this.trail=[];
    }
    landed(){
      const pos=this.body.position;
      let idx=0,md=1e9; for(let i=0;i<slots.length;i++){ const d=Math.abs(pos.x - slots[i].x); if(d<md){md=d; idx=i;} }
      const mult=slots[idx].mult; const bet=Math.max(0.1, parseFloat(betEl.value||'1')); const win=bet*mult*streak; balance+=win; streak=(mult>=5)?(streak+1):1; renderHUD();
      Matter.World.remove(world,this.body);
    }
    draw(){ const {x,y}=this.body.position; drawBall({x,y,r:this.r,trail:this.trail}); }
  }

  Matter.Events.on(engine,'collisionStart',ev=>{ for(const pair of ev.pairs){ const bodies=[pair.bodyA,pair.bodyB]; if(bodies.some(b=>b.label==='ball') && bodies.some(b=>b.label==='peg')){ const ballBody=bodies.find(b=>b.label==='ball'); const jitter=(rng()-0.5)*0.001; Matter.Body.applyForce(ballBody,ballBody.position,{x:jitter,y:0}); } } });

  // ===== UI actions =====
  function renderHUD(){ balanceEl.textContent='$'+balance.toFixed(2); streakEl.textContent='x'+streak; }
  function drop(){
    const bet=Math.max(0.1, parseFloat(betEl.value||'1')); if(balance<bet) return;
    balance-=bet; renderHUD();
    const spread=pegSpacingX*0.30; const centerX=(topLeft.x+topRight.x)/2;
    const spawnX = centerX + (rng()-0.5)*spread; const spawnY = topLeft.y - SPAWN_HEIGHT;
    const b = new Ball(spawnX,spawnY);
    Matter.Body.setVelocity(b.body,{x:(rng()-0.5)*0.8,y:0});
    balls.push(b);
  }

  manualBtn.addEventListener('click',()=>{ auto=false; manualBtn.classList.add('active'); autoBtn.classList.remove('active'); });
  autoBtn  .addEventListener('click',()=>{ auto=!auto; autoBtn.classList.toggle('active',auto); manualBtn.classList.toggle('active',!auto); });
  dropBtn  .addEventListener('click', drop);
  canvas   .addEventListener('pointerdown',(e)=>{ const r=canvas.getBoundingClientRect(); if(e.clientY< (r.top + topOffset + pegSpacingY*2)) drop(); });
  betHalf  .addEventListener('click',()=>{ betEl.value = Math.max(0.1, (+betEl.value||1)/2).toFixed(2); });
  betDouble.addEventListener('click',()=>{ betEl.value = Math.max(0.1, (+betEl.value||1)*2).toFixed(2); });
  riskEl   .addEventListener('change',()=>{ updateMultipliers(); draw(); });
  rowsEl   .addEventListener('input',()=>{ buildBoard(); draw(); });

  // ===== Draw helpers =====
  function drawBackground(){
    ctx.clearRect(0,0,W,H);
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#09162e'); g.addColorStop(1,'#070f22'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    // trapezoid frame: topLeft -> baseLeft -> baseRight -> topRight
    ctx.strokeStyle='rgba(156,209,255,.38)'; ctx.lineWidth=1.6; ctx.beginPath();
    ctx.moveTo(topLeft.x, topLeft.y);
    ctx.lineTo(baseLeft.x, baseLeft.y);
    ctx.lineTo(baseRight.x, baseRight.y);
    ctx.lineTo(topRight.x, topRight.y);
    ctx.closePath();
    ctx.stroke();
  }
  function drawPeg(p){
    ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='rgba(130,170,255,.45)'; ctx.shadowBlur=8; ctx.beginPath(); ctx.arc(p.x,p.y,p.r*0.9,0,TAU); ctx.fillStyle='rgba(130,170,255,.18)'; ctx.fill(); ctx.restore();
    const grad = ctx.createRadialGradient(p.x-2,p.y-2,1, p.x,p.y, p.r+5); grad.addColorStop(0,'#f4fbff'); grad.addColorStop(.35,'#cfe2ff'); grad.addColorStop(1,'#2b4c80');
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,TAU); ctx.fillStyle=grad; ctx.fill();
  }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function chipColor(i,n){ const t=Math.abs(i-(n-1)/2)/((n-1)/2); if(t>0.85) return getCSS('--chipRed'); if(t>0.70) return getCSS('--chipOrange'); if(t>0.50) return getCSS('--chipAmber'); if(t>0.30) return getCSS('--chipYellow'); return getCSS('--chipPale'); }
  function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  function shade(hex, amt){ const c=parseInt(hex.slice(1),16); let r=(c>>16)&255,g=(c>>8)&255,b=c&255; r=Math.min(255,Math.max(0,r+amt)); g=Math.min(255,Math.max(0,g+amt)); b=Math.min(255,Math.max(0,b+amt)); return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1); }
  function formatMult(m){ const v=+m; return (v>=10?Math.round(v):v.toFixed(1))+'x'; }
  function drawSlots(){ const y = (slots[0]?.y || (topOffset + (rows-1)*pegSpacingY + 36)) + 6; const h=28; for(let i=0;i<slots.length;i++){ const s=slots[i]; const x=s.x - (s.w-8)/2, w=s.w-8; const col=chipColor(i,slots.length); ctx.save(); ctx.shadowColor='rgba(0,0,0,.4)'; ctx.shadowBlur=10; roundRect(x,y,w,h,9); const gg=ctx.createLinearGradient(0,y,0,y+h); gg.addColorStop(0, shade(col, 14)); gg.addColorStop(1, col); ctx.fillStyle=gg; ctx.fill(); ctx.restore(); ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke(); ctx.save(); ctx.globalAlpha=.25; roundRect(x+2,y+2,w-4,h*.42,7); ctx.fillStyle='#fff'; ctx.fill(); ctx.restore(); const label=formatMult(s.mult); ctx.font='800 12px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle=(i<2||i>slots.length-3)?'#fff':'#1a1400'; ctx.fillText(label, x+w/2, y+h/2+0.5); } }
  function drawBall(b){ if(!b.trail) b.trail=[]; b.trail.push({x:b.x,y:b.y}); if(b.trail.length>10) b.trail.shift(); ctx.save(); ctx.globalCompositeOperation='lighter'; for(let i=0;i<b.trail.length;i++){ const t=b.trail[i], a=i/b.trail.length; ctx.globalAlpha=0.08+a*0.14; ctx.beginPath(); ctx.arc(t.x,t.y,b.r*(0.7+a*0.5),0,TAU); ctx.fillStyle='rgba(156,209,255,.55)'; ctx.fill(); } ctx.restore(); ctx.globalAlpha=1; const grad=ctx.createRadialGradient(b.x-2,b.y-3,1.5,b.x,b.y,b.r+7); grad.addColorStop(0,'#ffffff'); grad.addColorStop(.25,'#cfe6ff'); grad.addColorStop(1,'#2b4a7d'); ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.fillStyle=grad; ctx.fill(); }

  function draw(){ drawBackground(); for(const p of pegs) drawPeg(p); drawSlots(); balls.forEach(b=> b.draw()); }
  function update(){
    const now=performance.now(); if(auto && now-lastDrop>dropInterval){ drop(); lastDrop=now; }
    Matter.Engine.update(engine,1000/60);
    const floorY = baseLeft.y + 2;
    for(let i=balls.length-1;i>=0;i--){ const b=balls[i]; if(b.body.position.y>floorY){ b.landed(); balls.splice(i,1); } }
  }
  function loop(){ update(); draw(); requestAnimationFrame(loop); }

  // ===== Utils =====
  function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;}}

  // Init
  async function init(){ await loadPhysicsConfig(); applyMode(); size(); renderHUD(); loop(); }
  function renderHUD(){ balanceEl.textContent='$'+balance.toFixed(2); streakEl.textContent='x'+streak; }
  init();
})();
</script>
</body>
</html>
